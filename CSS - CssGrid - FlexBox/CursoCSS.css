/*Este archivo es un esquematico de como crear hojas de estilo en cascada con CSS, aqui es donde damos estilo y diseño a nuestras páginas web. CSS funciona con instrucciones que se componen de un selector y un grupo de propiedades a cambiar encerrados entre llaves*/


/*----------SELECTORES------------*/
/*Selectores: Hay varios tipos de selectores, y se utilizan de acuerdo a la necesidad, se recomienda de todos modos utilizar mayormente un solo tipo de selector. A continuacion vamos a ejemplificar los distintos tipos de selector*/

/*Selector de Tipo, se seleccionan los elementos por el tipo de etiqueta*/
h1 {color: black;}

/*Selector por clase, selecciona todos los elementos que en el archivo HTML5 tienen el atributo class="nombreDeLaClase" es decir tienen la clase (nombreDeLaClase)*/
.nombreDeLaClase{color: black;}

/*Selector por ID, funciona de la misma manera que el selector por clase, es decir selecciona todos los elementos que el archivo HTML5 tienen el atributo id="identificador" es decir tienen el ID identificador. No es recomendable utilizar este selector para varios elementos, o lo que es lo mismo, no es recomendable que haya varios elementos con el mismo ID, ya que esto es una mala práctica en programacion*/
#identificador{color: black;}

/*Selector por atributo, selecciona los elementos en HTML5 que compartan el atributo y el valor. Por ejemplo utilizamos el atributo atributo="valor"*/
[atributo="valor"]{color: black;}

/*Seleccion por descendiente, es una combinacion de los demas selectores combinados para dar mas especificidad, los selectores se colocan en orden descendiente, con el menos especifico a la izquierda y el más especifico a la derecha. Supongamos una etiqueta div con la clase  class="container" que contiene una etiqueta de parrafo entre otras cosas más, para seleccionar solo la etiqueta parrafo deberiamos  asignarle un ID, pero como esto es rebuscado cuando hay muchos elementos podemos seleccionar primero el div con la clase container, dejar un espacio y luego seleccionar la etiqueta "p" del parrafo buscado. Veamos esto*/
.container p {color:  black;}

/*Por Pseudoclases, son selectores que activan la modificacion cuando sucede algun evento especifico. Un ejemplo de esto es cuando deseamos cambiar el color de un texto segun el raton pase encima del mismo. Esto lo hacemos con la pseudoclase hover.*/
p:hover {color: black;}

/*Selector universal, selecciona todos los elementos. Solo modifica los atributos que no se hayan definido por otro selector antes. Es decir si cambiamos el color de una caja y luego cambiamos los colores de todos los elementos, el selector universal no va a variar el color de esa caja porque el atributo ya estaba definido*/
*	{color: black;}

/*Estos electores tienen cada uno un nivel de importancia.  Del menos prioritario arriba al más prioritario abajo, siendo el important el selector mas prioritario o con más jerarquia: 
1. elementos y pseudo-elementos: es decir los selectores por tipo.
2. clases, pseudo-clases y atributos
3. identificadores:  selectores por ID
4. estilos en linea:  es cuando se modifica el estilo desde el propio archivo HTML
5. !important : se utiliza colocando la palabra !important al lado del valor de la propiedad, en el espacio dentro de las llaves.

Si queremos colocar dos selectores para un mismo grupo de propiedades, podemos colocar los dos selectores antes de las llaves y separarlos por una coma.*/


/*--------------UNIDADES DE MEDIDA---------------*/
/*Unidades de Medida: En CSS tenemos dos tipos de unidades de medida, las unidades fijas como son los pixeles (px) o los milimetros (mm),  y las medidas relativas, las cuales dependen de la caja contenedora como son los porcentajes (50% del contenedor, 30% del contenedor, etc) o los em y los rem*/
.caja1 { 
	font-size: 20px;
	font-size: 2mm;
	font-size: 1cm;
	font-size: 1in; /*Una pulgada*/
	font-size: 1pt; /*Aprox un punto es 1/72 de 1in*/
}      
/*Las medidas relativas son mejores para el diseño responsive.*/
.caja1 {
	width: 100vw; /*Anchura del 100% de la ventana gráfica. vw=viewport width*/
	height: 100vh; /*Alto del 100% de la ventana gráfica. vh=viewport height*/

	font-size: 50%;
	font-size: 1em; /**/
	font-size: 1rem; /*rem es relativo al tamaño de la fuente del elemento raiz (elemento padre directo), por defecto 1 rem es 16px*/
}


/*-----------PROPIEDADES DE TEXTO------------*/
p {
	font-size: 20px;
	font-family: Georgia;
	line-height: 2;
	font-weight: 400;
	font-size: 2em;

	color:  red;

	text-align: center;
	text-align: justify;
	text-align: left;
	text-align: right;

	letter-spacing: 1px; /*Genera espaciados entre las letras*/
}
/*Para colocar otras tipografias, podemos importarlas de google, ingresamos a goolge fonts y elegimos una. Copiamos la etiqueta link en el archivo HTML, luego la implementamos. Cabe aclarar que es conveniente colocar dos tipografias separadas por una coma, para el caso de que no se encuentre la primera, se utilice la segunda*/
p {
	font-family: 'Georgia', sans-serif;
}


/*-------------PROPIEDADES DE CAJA------------------*/
h2 {
	background-color: #a22;
	padding: 20px; /*Distancia entre el texto y la caja, un numero los cuatro padding de 20px, dos numeros eje y" y eje "x", cuatro numeros
	top, right, bottom, left*/
	height: 100px; /*Altura*/
	width: 100px; /*Ancho*/
	text-align: center; /*Centra el texto en la caja*/
	margin: 15px; /*Distancias entre caja y caja, aplican las mismas reglas para el orden de los valores que en el padding*/
	margin: auto; /*Centra la caja*/

	border-radius: 5px; /*Bordes redondeados*/
	border: 4px, solid, blue; /*Grosor del borde, tipo de borde y color de borde*/

	opacity: 0.1;/*Es la transparencia de la caja, con 0 desaparece y 1 es el color pleno, los decimales son los intermedios*/

	box-sizing: border-box;
	box-shadow: 2px, 3px, 5px, 0, black; /*Desplazamiento en x, desplazamiento en y, desenfoque, cuanto de borde tendra la sombra, color*/
	text-shadow: 2px, 2px, 3px, black; /*Dezplazamiento en x, desplazamiento en y, desenfoque, color*/	
	transform: rotate(45deg); /*Rotacion (la propiedad transform tiene muchos otros atributos)*/
}


/*-------------OUTLINE---------------*/
/*Es una propiedad que permite enmarcar elementos dando un borde a la caja, con la diferencia de que outline no mueve los demas elementos para dar espacio al nuevo borde, simplemente lo superpone arriba.*/
.caja1 {
	outline: 5px, solid, red; /*grosor, tipo de borde, color*/
}


/*-----------POSITION------------*/
/*Con la propiedad position podemos colocar los elementos en distintas partes de la pantalla. Al hacerlo nuestro elemento adquiere 4 nuevas propiedades que referencian la caja a un valor en absoluto en la pantalla. Estas propiedades son top, left, right, bottom. Las mas importantes son top y left*/

/*Position relative: Da una posicion relativa a donde debiese estar posicionado este elemento en la pantalla. El elemento se mueve y además guarda el espacio que le corresponde por defecto*/
.caja1 {
	position: relative;
	top:  15px; 
	left: 20px;
}
/*Position Absolute: Da una posicion relativa a la ubicacion del elemento padre. Si no hay elemento padre se utiliza la etiqueta de body*/
.caja1 {
	position: absolute;
	top:  115px; 
	left: 50px;
}
/*Position Fixed: Da una posicion respecto a lo que estamos viendo en el explorador, es decir no se posiciona respecto a los demas elementos del documento, sino respecto a la pantalla del explorador. Por lo que si se hace scroll el elemento se seguira viendo en el mismo lugar*/
.caja1 {
	position: fixed;
	top:  15px; 
	left: 20px;
}
/*Position Sticky: Es una mezcla entre static y fixed, la caja se comporta como position: relative mientras no se hace scroll, luego de hacer scroll si la caja esta por ser tapada por el navegador entonces esta cambia su comportamiento y se vuelve fixed*/
.caja1 {
	position: sticky;
	top:  15px; 
	left: 20px;
}


/*---------Z-INDEX----------*/
/*El valor de z-index nos ordena los elementos cuando estos se enciman o apilan. Un numero más alto significa que la caja esta mas arriba*/
.caja1 {
	z-index: 2;
}

/*--------OVERFLOW-----------*/
/*Overflow(excedente): Es una propiedad que nos permite definir que sucede con el contenido de una caja cuando este no entra en ella, esto funciona tanto con texto como con imagenes y otros elementos. Existen varios valores para la propiedad overflow, estos son: auto (donde el explorador coloca las barras de scroll del contenido si es necesario), scroll (donde la barra de scroll esta activa siempre), hidden (donde lo que sobra del contenido se oculta y no aparece la barra de scroll), luego por ultimo esta el valor por defecto que es visible (donde el  contenido se muestra y sobresale de la caja)*/
.caja1{
	overflow: auto;
	overflow: visible;
	overflow: hidden;
	overflow: scroll;

	overflow-x: scroll;
	overflow-y: scroll;
}

/*---------FLOAT-----------*/
/*Float: Esta es una propiedad que permite que los elementos floten a la izquierda o a la derecha del contenedor que los enmarca, sin importar el orden que este ocupa en el mismo*/
.caja1{
	float: left;
	float: right;
}

/*---------PSEUDO-ELEMENTOS y PSEUDO-CLASES----------*/
/*Pseudoelementos: Son selectores que aplican a "elementos" que forman parte de otros elementos verdaderos, por ejemplo la primer letra de un parrafo, la ultima linea de un texto, etc. Ejemplificaremos algunos de ellos, los cuales estan referenciados a un parrafo p. Los primeros 4 pseudoelementos funcionan solo con etiquetas de BLOCK*/
p::first-line {
	font-size: 3em;
}
p::first-letter {
	font-size: 3em;
}
p::placeholder {
	font-size: 3em;
}
p::selection {
	font-size: 3em;
}
p::before {
	font-size: 3em;
	content: "contenido extra que aparece antes del p";
}
p::after {
	font-size: 3em;
	content: "contenido extra que aparece despues del p";
}
.items:nth-child(6) {
	padding: 10px; /*La propiedad nth-child modifica un elemento segun su posicion en un grupo de elementos hermanos. Si en html declaramos 10 items en un mismo contenedor podemos modificar el segundo contenedor con nth-child (2)*/
}


/*Pseudoclases: Son selectores que realizan un cambio en el diseño cuando ocurre un evento, como por ejemplo que se haga click en un enlace se dice que estan a la escucha de un evento.*/

.caja1:hover {
	color: red; /*la modificacion se activa cuando el raton esta encima del elemento*/
}
a:link {
	color: red; /*Se aplica un color siempre y cuando el link no haya sido visitado*/
}
a:visited {
	color: red; /*Se aplica un color cuando el link ya se haya visitado*/
}
.caja1:active {
	color: red; /*Se activa la propiedad cuando se esta clickeando el elemento, cuando se deja de clickear vuelve a la normalidad*/
}
.caja1:focus {
	color: red; /*Se activan las modificaciones cuando el input esta enfocado, es decir cuando lo clickeamos y esta seleccionado*/
}

/*Tambien se pueden hacer transiciones con esto, por ejemplo si con la pseudoclase hover cambiamos la altura, el ancho y el color de fondo, podemos aplicar la propiedad transition para definir un tiempo en el que ese cambio deba realizarse.*/
.caja1 {
	height: 200px;
	width: 200px;
	background: slateblue;
	transition: background 1s, height 0.5s, width .5s; /*Definimos los tiempos de cambio de cada propiedad*/
	transition: all 1s; /*Si todas las prop. tienen el mismo tiempo de cambio entonces se puede abreviar de esta manera*/
}
.caja1:hover {
	background: darkslateblue;
	height: 300px;
	width: 300px;
}
/*El transition se escribe obligatoriamente en el selector sin el evento*/
/*Existen mas pseudoclases y pseudoelementos, solo deben buscarse en internet*/

/*----------OBJECT-FIT---------------*/
/*Object Fit: Sirve para acomodar imagenes cuando su resolucion no coincida con el tamaño del contenedor que la contiene, cada uno de los valores indica una forma de posicionarla*/
.caja1 img {
	object-fit: contain; /*La imagen mantiene su proporcion, y se centra en el contenedor (si el contentedor tiene otra proporcion se veran los espacios faltantes)*/
	object-fit: none; /*Pone la resolucion de la imagen original*/
	object-fit: cover; /*La imagen mantiene su proporcion, se centra y rellena todo el contenedor recortando la imagen*/
	object-fit: scale-down; /*realiza contain o none, dependiendo de cual deja la resolucion mas baja*/
}

/*Object-Position: Coloca la imagen ladeada hacia derecha, izquierda, arriba o abajo. Tambien se pueden dar medidas relativas y des-centrar la imagen del punto central*/
.caja1 {
	object-position: left;
	object-position: right;
	object-position: top;
	object-position: bottom;
	object-position: -1em; /*dando valores numericos*/
}

/*Tipos de cursor: Existen distintos tipos de cursor que se pueden aplicar cuando el raton se posicione por ejemplo, arriba de un elemento*/
.caja1:hover {
	cursor: all-scroll; /*se puede aplicar cuando el raton este sobre una imagen*/
	cursor: zoom-in; /*se puede usar cuando buscamos hacer un zoom en la página web*/
	cursor: progress; /*se puede usar cuando mostramos una pantalla de carga*/
	cursor: context-menu;
	cursor: col-resize; /*se puede aplicar cuando buscamos recortar una imagen horizontalmente*/
	cursor: copy; /*se puede usar cuando tenemos que copiar algo*/
}
/*existe una lista completa de todos los tipos de cursores y se encuentra en la siguiente página web: https://www.w3schools.com/cssref/tryit.asp?filename=trycss_cursor */


/*Colorización: Existen varias formas de dar un color en css esto se da con los colores con nombre, con los rgb, rgba, hexadecimal, etc. Si bien es interesante aprender las distintas nomenclaturas para colorizar, una forma práctica es mezclar el color visualmente y luego buscar su codigo de color.*/
.caja1 {
	color: #ff0000;
	color:  rgb(170, 200, 34);
}

/*-------INHERIT-------*/
/*Cuando a una propiedad, cualquiera sea, le damos el valor inherit, le estamos diciendo que herede el valor de esa propiedad de su caja padre*/


/*-----------------------FLEXBOX---------------------------*/
/*Flexbox: Es una nueva forma de maquetar las páginas web, lo que hacemos con esto es que nuestros contenedores en la página web tengan más flexibilidad. Notese que Flex-Box = Cajas-Flexibles. Cabe resaltar que cuando le damos a un contenedor display: flex; este contenedor se comportara como un bloque, pero sus cajas hijas no lo harán, ellas serán cajas flexibles o flex-items. Y esto funcionara así para todas las cajas que son hijas directas de la caja flex (no funciona con cajas nietas, bisnietas, etc).
Las cajas en flexbox se adaptan al tamaño de su contenedor y en base a su contenido (si una caja tiene más contenido ocupara una mayor porción del contenedor), de manera automatica. 
Flexbox tiene dos ejes, el main axis (x), y el cross axis (y), los cuales tienen una dirección (como los vectores), el main axis tiene un main-start a la izquierda y un main-end a la derecha, luego el cross axis tiene un cross-start arriba y un cross-end abajo. Esto es crucial para ordenar los elementos.
Es importante indicar, que todas las propiedades que vamos a ver se aplican al contenedor y no a los flex items.*/

/*Flex direction: Es un indicativo de como se van a ordenar las cajas en nuestro contenedor flex*/
.contenedor {
	display: flex;
	flex-direction: row; /*Valor por defecto: Las cajas se ordenan de izq a der,  y se ajustan al contenido, buscando igualar sus alturas*/
	flex-direction: row-reverse; /*Las cajas se ordenan de der a izq, y se ajustan al contenido buscando igualar sus alturas*/
	flex-direction: column; /*Las cajas se ordenan de arriba a abajo y se ajustan al contenido buscando igualar sus anchos*/
	flex-direction: column-reverse; /*Las cajas se ordenan de abajo hacia arriba, y se ajustan al contenido buscando igualar sus anchos*/
}
/*Flex Wrap: Especifica si los elementos "hijos" son obligados a permanecer en una misma línea o pueden fluir en varias líneas. Util cuando la resolucion no permite que se muestren todos en una linea*/
.contenedor {
	display: flex;
	flex-wrap: nowrap; /*Fluyen en una linea, si no estan definidas las dimensiones de los flex-items, estos se achican hasta ser cero, si estan definidas entonces los flex-items se desbordan del contenedor*/
	flex-wrap: wrap; /*Al achicar el tamaño del contenedor, estas cajas fluyen a la linea de abajo*/
	flex-wrap: wrap-reverse; /*Las cajas fluyen hacua arriba al achicar el contenedor*/
}
/*Flex flow: Abrevia flex-direction y flex-wrap. En valores se coloca primero el valor de direction y luego el valor de wrap.*/
.contenedor {
	display: flex;
	flex-flow: column wrap;
}
/*Justify Content: Define cómo el navegador distribuye el espacio entre y alrededor de los items flex, a lo largo del eje principal de su contenedor.  https://developer.mozilla.org/es/docs/Web/CSS/justify-content    */
.contenedor {
	justify-content: flex-start; /*Los items flex se colocan comenzando desde el comienzo principal*/
	justify-content: flex-end; /*Los items flex se colocan comenzando desde el final principal*/
	justify-content: center; /*Los items flex son colocados hacia el centro de la línea. Los items flex se alinean al ras entre sí y en torno al centro de la línea.*/
	justify-content: space-between; /*Los items flex se distribuyen uniformemente sobre la línea, el espacio adyacente entre dos items es el mismo*/
	justify-content: space-around; /*Los items flex se alinean uniformemente de tal manera que el espacio entre dos items adyacentes es el mismo. El espacio vacío anterior al primer item y posterior al último item equivale a la mitad del espacio entre dos items adyacentes. El margin entre cada caja es igual*/
}
/*Align Items: Asi como justify content alinea los elementos en el main axis, esta propiedad lo hace en el cross-axis*/
.contenedor {
	align-items: flex-start; /*Coloca las cajas arriba al inicio del cross axis*/
	align-items: flex-end; /*Coloca las cajas abajo al fin del cross axis*/
	align-items: center; /*Centra las Cajas verticalmente*/
	align-items: stretch; /*Propiedad por defecto: Estira el contenedor a todo lo largo del cross axis*/
	align-items: baseline; /*Todos los elementos flexibles son ajustados de modo que sus bases queden alineadas.*/
}
/*Align Content: Util para alinear los elementos con mas de una linea en el cross-axis. No es válida para elementos de una linea.*/
.contenedor {
	/* Ajusta las líneas desde el inicio del cross axis */
	align-content: flex-start;

	/* Ajusta las líneas desde el final del cross-axis (eje transversal)*/
	align-content: flex-end;

	/* Ajusta las líneas alrededor del centro del eje transversal */
	align-content: center;

	/* Distribuye las líneas a lo largo del eje transversal, de principio a fin */
	align-content: space-between;

	/* Distribuye las líneas a lo largo del eje transversal, igualmente espaciados */
	align-content: space-around;

	/* Estira las líneas para que ocupen el eje transversal completo */
	align-content: stretch;
}
/*Ahora veremos las propiedades reservadas para los Flex Items*/
/*Align Self: La propiedad align-self alinea los elementos flexibles de la línea flexible actual, reemplazando el valor de align-items. Si el límite transversal de alguno de los elementos está definido como auto, el valor de align-self es ignorado.*/
.flex-item {
	align-self: auto;
	align-self: flex-start;
	align-self: flex-end;
	align-self: center;
	align-self: baseline;
	align-self: stretch;
}
/*Min-Width, min-height: Define un ancho mínimo para mi caja flexible*/
.flex-item {
	min-width: 300px;
	min-height: 200px;
}

/*flex Basis: La propiedad de CSS flex-basis especifíca la base flexible, la cual es el tamaño inicial de un elemento flexible. Ésta propiedad determina el tamaño de una caja de contenidos a no ser que se haya especificado de otra forma*/
.flex-item {
	flex-basis: 100px;
}

/*Flex Grow: Si definimos las dimensiones de las cajas en uno de los ejes, y en este eje sobra espacio debido a que la resolucion es mucho mayor, podemos utilizar flex grow para que reparta el espacio sobrante a las cajas, esto lo hace sumando la porcion del sobrante que le indiquemos al width de nuestro flex-item. Esto es util ya que la propiedad se refrezca siempre que modifiquemos el tamaño del flex-container por lo que podemos ajustar las cajas dinamicamente.
Para asignarle una porcion del espacio sobrante a una de las cajas debemos colocarlo en forma de fracciones de una suma. Por ejemplo si tenemos tres cajas y queremos darle el 2/4 parte del espacio sobrante a la primera y 11/4 a la segunda y a la tecera hariamos lo siguiente.*/
.caja-flex-1 {
	flex-grow: 2;
}
.caja-flex-2 {
	flex-grow: 1;
}
.caja-flex-3 {
	flex-grow: 1;
}
/*En cambio si queremos repartir el sobrante equitativamente le dariamos 1/3 del espacio sobrante a cada caja. Esto es:*/
.caja-flex-1 {
	flex-grow: 1;
}
.caja-flex-2 {
	flex-grow: 1;
}
.caja-flex-3 {
	flex-grow: 1;
}
/*Esto se puede abreviar dando una clase para los flex item.*/
.flex-item {
	flex-grow: 1;
}

/*Flex shrink: La propiedad CSS flex-shrink especifica el factor de contracción de un flex item. Los flex items se encogerán para llenar el contenedor de acuerdo a su número flex-shrink , cuando el tamaño por defecto de los flex items sea mayor al de su contenedor flex container.*/
.flex-item {
	flex-shrink: 2;
	flex-shrink: 0.6;
}

/*Flex: Es una propiedad que abrevia las tres anteriores. Al invocarla debemos pasarle como primer parametro el valor de nuestro flex-grow (que naturalmente repartira equitativamente el espacio), como segundo valor el de flex-shrink y como tercer parametro el valor de blex-basis. Esta propiedad necesita obligatoriamente que le pasemos el primer parámetro al menos*/
.flex-item {
	flex: 1 0 50px;
}

/*Order: Esta propiedad ordena los elementos que se encuentran en el main axis, cuando mayor sea su valor de order la caja se encontrara más al final del main axis, sin importar el orden en que fue declarada. Informalmente podemos decir que funciona como la propiedad z-index pero en el main axis*/
.caja-flex-1 {
	order: 50;
}
.caja-flex-2 {
	order: 1;
}
/*La caja-flex-1 se mostrara a la derecha de la caja-flex-2 aunque se haya declarado despues. Notese que si cambiamos el modo en el que corren los ejes con flex-direction esta propiedad se puede utilizar en el eje vertical, de derecha a izquierda, etc.*/


/*---------CSS GRID----------*/
/*Es otro valor de la propiedad display, en donde el container cuya propiedad sea display:grid; le dara a sus elementos hijos nuevas propiedades, solo hijos directos. Se dice grid-container porque el mismo a partir de ahora estara segmentado en grillas internas.
Grid Item: Son todos los elementos que estan dentro del grid-container y no tienen que necesariamente estar relacionados con cada una de las celdas del grid-container.
Grid Cell: Son cada una de las celdas de la grilla.
Grid Track: Hay dos grid-track,Grid-Column y Grid-Row, son cada columna o fila que haya en nuestra grilla, el total de los grid-track es la suma de las filas y columnas. En general se denominan simplemente como filas y columnas.
Grid Area: Son un conjunto de celdas que nosotros seleccionemos y definimos, la condicion es que las celdas involucradas deben ser consecutivas.
Grid Line: Son las lineas divisorias de nuestra griila, las cuales marcan la separacion entre las distintas filas y las distintas columnas.*/

/*Propiedades que se aplican al grid container.*/
/*Con template-rows y template-columns generamos las filas y columnas de nuestra grilla*/
.container {
	display: grid;
	grid-template-rows: 150px 150px 150px; /*Se crean tres filas de 150px*/
	grid-template-rows: repeat(3, 150px) 75px; /*usando la funcion repeat (que es como un bucle) se crean 3 filas de 150px y una cuarta fila de 75px*/
	grid-template-columns: 1em 1fr; /*Se pueden utilizar unidades de medida relativas o mezclar unidades. Se recomienda usar fr para ajustar las columnas automaticamente*/
	grid-template-columns: 50% 50%;
	grid-template-columns: 100px 1fr;
}
/*Para el trabajo con css-grid existe una nueva unidad de medida llamada fr que indica un valor de una fraccion del espacio disponible, si construimos tres columnas con un valor de 1fr cada una el espacio disponible dentro del contenedor asignara un tercio a cada columna y estas se ajustaran de manera flexible. Del mismo modo si a una de ellas le asignamos 2fr y dejamos las dos restantes con 1fr, entonces el espacio del grid-container se divide en 4 asignando la mitad del espacio a una columna y un cuarto del espacio a las dos columnas restantes.*/

/*Grid-Row-Gap y Grid-Column-Gap: Son dos propiedades que se resumen en grid-gap y generan espacios entre celdas pero no entre el contenedor. De manera informal trabaja como la propiedad margin, pero no asigna espacios entre las celdas y el borde del contenedor, solo espacios entre ellas*/
.container {
	grid-row-gap: 30px;
	grid-column-gap: 10px;
	grid-gap: 10px 5px; /*si se coloca un solo valor los valores de gap de column y row se igualan.*/
}

/*Propiedades que se aplican a los grid-items*/
/*Grid-Row y Grid-Column: Son propiedades que definen el tamaño de nuestros componentes si deseamos que ocupen más de una celda. Si queremos que un elemento ocupe las dos primeras columns de mi tabla en ancho y en alto ocupe solo una. Lo que hacemos es lo siguiente.*/
.grid-item:first-child {
	grid-row: 1 / 2; /*El elemento inicia en la linea 1 de las filas y termina en la linea 2 de las filas*/
	grid-column: 1 / 3; /*El elemento inicia en la linea uno y termina en la linea tres*/
}
/*Exixte otra forma de definir esto, y hace uso de la palabra reservada span, con esto la declaracion de elementos es mas intuitiva*/
.grid-item:nth-child(6){
	grid-column: 1 / span 3; /*Arranca en la linea uno y ocupa tres columnas*/
}
/*Al definir elementos de esta manera debemos tener en cuenta que si un elemento ocupa mas de una celda, este, empujara a los otros y los obligara a moverse corriendolos de su lugar*/

/*Grid implicito: Cuando tenemos una grilla y por algún motivo nos sobran items en ella, como por ejemplo puede darse el caso de que realicemos una grilla de 12 celdas y tengamos 14 items, va a suceder que los items sobrantes se colocaran por defecto en una nueva fila sin formato, con lo que seran poco visuales. Esta parte del grid se denomina grid implicito y con la siguiente list de propiedades buscamos arreglar algunos inconvenientes que puede generar*/
.grid-container {
	grid-auto-rows: 150px; /*Funciona como el template rows pero para el grid implícito*/
	grid-auto-columns: 35px; /*Funciona como el template columns, pero para el grid implícito*/
	grid-auto-flow: row; /*Los items sobrantes van a una nueva fila (por defecto)*/
	grid-auto-flow: column; /*Los items sobrantes van a una nueva columna*/
	grid-auto-flow: dense; /*Si quedan huecos en nuestro grid y el grid-implicito no puede rellenarlo, entonces se utiliza la propiedad dense en donde un algoritmo detecta el item que quepa, más cercano, y lo coloca en el hueco.*/
}

/*Grid Dinámico: es una forma de customizar un grid para generar estructuras dinámicas, de este modo le agregamos muchas funcionalidades a nuestra grilla.*/
.container {
	grid-template-columns: repeat(3, min-content); /*min.content: El grosor de las columnas se ajusta al contenido mínimo.Tres columnas cada una con el ancho mínimo que permitan sus respectivos contenidos*/
	grid-template-columns: repeat(3, max-content); /*max-content: El grosor de las columnas o filas se ajusta al contenido máximo. Tres columnas cada una con el ancho máximo que permitan sus respectivos contenidos*/
	grid-template-rows: repeat(3, minmax(1fr, 300px)); /*minmax: Coloca ancho mínimo y ancho máximo*/
	grid-template-rows: repeat(3, minmax(min-content, max-content)); /*Abrevia min-content y max-content*/

	grid-template-rows: repeat(auto-fill, minmax(min-content, max-content)); /*auto-fill: genera nuevas columnas (o filas)o las borra, cada vez que debido a un cambio en la resolucion de la pantalla, esto lo requiera*/
	grid-template-columns: repeat(auto-fit, minmax(min-content, max-content)); /*auto-fit: trabaja igual que auto-fill, pero cuando ya no se pueden generar más columnas (o filas), porque no hay tantos items, entonces pasa a escalar los items para que ocupen todo el ancho del grid-container*/
}

/*Alineacion en grid: Hay varias formas de alinear nuestros elementos en CSS-Grid*/
.container {
	/*alinear los elementos como grupo respecto a su grid-container*/
	justify-content: start; /*eje horizontal (main-axis), sus valores son: start, center, end, etc*/
	align-content: center; /*eje vertical (cross-axis), sus valores son: start, center, end, etc*/

	/*para alinear los items, tiene una jerarquia menor que justify-content y align-content*/
	justify-items: start; /*start, center, end*/
	align-items: center; /*start, center, end*/
}
/*Se puede alinear cada item independientemente de los demas con las propiedades justify-self y align-self vistas anteriormente*/
.grid-item:first-child {
	justify-self: center;
	align-self: start;
}
/*Grid Areas: Se pueden ralizar tablas asignando distintas areas para usos reservados, la forma de hacerlo es la siguiente. Primero trabajamos con el grid-container y construimos la grilla*/
.container {
	display: grid;
	/*Creamos una grilla de tres columnas y cuatro filas, donde cada celda tiene un nombre*/
	grid-template-areas: 
	"header" "header" "header"
	"main" "main" "aside" 
	"main" "main" "aside" 
	"footer" "footer" "footer";
}
/*con la prop. grid-area asignamos a cada uno de los items un area, formada por todas las celdas que compartan el nombre del valor.*/
.grid-item:first-child {
	grid-area: header;
}
.grid-item:nth-child(2) {
	grid-area: main;
}
.grid-item:nth-child(3) {
	grid-area: aside;
}
.grid-item:last-child {
	grid-area: footer;
}

/*Grid Lines: En ocasiones para trabajar con items que ocupan más de una celda debemos utilizar grid-row y grid-column y luego pasarle como valor el numero de la linea. Como esto es anti-intuitivo en grid de granes dimensiones entonces buscamos darles nombres especificos a las lineas de la siguiente manera.*/
.container {
	display: grid;
	/*asignamos los nombres de las lineas colocandolos entre corchetes y en el lugar donde se van a ubicar*/
	grid-template-rows: [linea1] 150px [linea2] 150px [linea3] 150px [linea4];
	grid-template-columns: [inicio] 150px [final];
}
.grid-item:first-child {
	/*pasamos el nombre de la linea en vez del numero de linea. Esto es más intuitivo*/
	grid-column: inicio / final;
	grid-row: linea1 / linea3;
}
/*grid-template: shorthand que abrevia grid-template-row, grid-template-column y grid-template-area. Se debe investigar sobre esto*/
/*grid: shorthand que resume todas las propiedades del grid-container*/


/*----------RESPONSIVE DESIGN------------*/
/*Media queries: son condicionales de css y se utilizan cuando se desea modificar la página web o aplicación en función del tipo de dispositivo (como una impresora o una pantalla) o de características y parámetros específicos (como la resolución de la pantalla o el ancho del viewport del navegador). Su sintaxis es simple, se escribe @media, luego el tipo de media querie (all y screen son los más utilizados), un operador y luego la condicion. Veamos unos ejemplos*/

/*si no se agrega el modificador screen entonces por defecto es all*/
@media (min-width: 600px){
	.item{background-color: aqua;}
}
/*el modficador and, nos dice que si el media es una pantalla (screen) y su width es menor a 400px, entonces que ejecute la condicion*/
@media screen and (min-width: 400px){
	.item{background: red;}
}
/*se pueden colocar varias sentencias, con el operador and, se deben cumplir todas las condiciones para que se aplique la modificacion*/
@media screen and (min-width: 400px) and (orientation: landscape) {
	.item {background-color: beige;}	
}
/*Las listas separadas por comas se comportan como el operador or cuando es usado en media queries. Cuando utilice una lista separada por comas y alguno de los queries retorna verdadero, el estilo o la hoja de estilos sera aplicada.*/
@media (min-width: 700px), handheld and (orientation: landscape) {
	.item {background-color: blueviolet;}
}
/*El operador not aplica a todo el query y retorna verdadero si es posible y sino retorna falso. En este caso si no se cumple all y monocrome, la modificacion no se efectua*/
@media not all and (monochrome) {
	.item {background-color: chocolate;}
}
/*Existen ademas de esto muchas funciones multimedia para adaptar nuestras páginas web. Recomendamos revisar la documentacion*/


/*---------TRANSITION-----------*/
/*Es una propiedad que nos premite realizar transiciones en nuestras páginas web*/
.container {
	width: 300px;
	transition-property: width; /*se coloca la o las propiedades a modificar. Se puede colocar all pero esto consume muchos recursos*/
	transition-duration: 1s; /*duracion de la transicion*/
	transition-delay: 1s; /*espera hasta que empieze la transicion*/
	transition-timing-function: ease; /*evolucion de la transicion en el tiempo. Ej: comienza rápido y termina lento, etc. Algunos de sus valores son:
	linear: transicion evoluciona lineal
	ease: más veloz al inicio y lenta al final
	ease-in: lenta al inicio y rapida al final*/

	/*el shorthand transition nos permite abreviar las 4 propiedades anteriores*/
	/* nombre de la propiedad | duración */
	transition: margin-left 4s;

	/* nombre de la propiedad | duración | retardo */
	transition: margin-left 4s 1s;

	/* nombre de la propiedad | duración | función | retardo */
	transition: margin-left 4s ease-in-out 1s;

	/* Aplicar a 2 propiedades */
	transition: margin-left 4s, color 1s;
}
.container:hover {
	width: 400px; /*propiedad que cambia*/
}

/*--------ANIMACIONES---------*/
/*Para programar animaciones en CSS se recurre a una regla nueva llamada keyframes, veamos la estructura básica de una de ellas: Primero se colocan dos parametros obligatorios a nuestra caja. El nombre de la animacion asociada a la caja y la duracion de la animación. */
.caja1 {
	animation-name: animacion1;
	animation-duration: 1s;
}
/*Luego se coloca un keyframes y el nombre de la animacion. Se colocan dos selectores dentro, uno llamado form (con las propiedades iniciales) y otro llamado to (con las propiedades finales)*/
@keyframes animacion1 {
	from {
		left: 0;
	} to {
		left: 90%;
	}
} 
/*existen otras propiedades que se colocan en el selector de la caja, estas son:*/
.caja1 {
	animation-iteration-count: 3; /*la animacion se repite 3 veces*/
	animation-iteration-count: infinite; /*la animacion se repite indefinidamente*/

	animation-direction: normal; /*corre normal, por ejemplo de izq a derecha o de arriba a abajo*/
	animation-direction: reverse; /*corre alrevés, por ejemplo de derecha a izquierda*/
	animation-direction: alternate; /*alterna las direcciones, y empieza normalmente*/
	animation-direction: alternate-reverse; /*alterna las direcciones, y empieza alrevés */

	animation-fill-mode: forwards;
	animation-fill-mode: both;
}
/*Una forma más exacta que el from-to para indicar los fotogramas clave es utilizar porcentajes. De este modo indicamos con más precision las distintas fases de la transicion*/
@keyframes animacion2 {
	0% {
		color:aqua;
	} 36% {
		color: azure;
	} 90% {
		color:rgb(170, 200, 34);
	} 100% {
		color: crimson;
	}
}

/*---------CUBIC BEZIER----------*/
/*Cubic bezier es una propiedad que controla el flujo y la curva de velocidad de una animacion o una transicion. Esta curva se determina dando dos puntos en un plano cartesiano. No veremos la formula de bezier, simplemente daremos valores.*/
.caja1 {
	/*cubic bezier es un valor del transition-timing-function y del animation-timing-function*/
	animation-timing-function: cubic-bezier(1, 0, 0, 1); /*cubic-bezier(x1,y1,x2,y2)*/
}
/*Se recomienda utilizar generadores de curvas para trabajar con esto: https://cubic-bezier.com/#.17,.67,.83,.67*/


/*-------TRANSFORM--------*/
/*Es una propiedad que se utiliza para realizar transformaciones geométricas en elementos, ya sea desplazandolos o escalandolos. Cabe destacar que al utilizar la traslacion con la propiedad transform, en vez de utilizar position, margin o padding, el movimiento del elemento no afecta a las demas cajas en el flujo de la página y consume considerablemente menos recursos.*/
.caja1 {
	transform: translateX(2mm);
	transform: translateY(3rem);
	transform: translate(20%, 70px); /*El primer parámetro indica el desplazamiento en x, y el segundo el desplazamiento en y*/

	transform: scaleX(1.5); /*Escala en x, el parámetro es el coeficiente de transformacion*/
	transform: scaleY(1.5); /*Escala en y*/
	transform: scaleZ(2); /*Escala en Z*/
	transform: scale(1.5, 1.5); /*Un valor: escala en x. Dos valores: escala en x, escala en y*/
	transform: scale3d(1.5, 1.5, 2); /*escala en x, escala en y, escala en z*/

	transform: rotateX(1.5turn); /*rotacion en x*/
	transform: rotateY(60deg); /*rotacion en y*/
	transform: rotateZ(12grad); /*rotacion en z*/
	transform: rotate(90deg, 45rad); /*rotacion en x, y*/

	transform: matrix(); /*es una funcion CSS que define una matriz de transformacion 2D, sus parámetros son: a, b, c, d, tx, ty*/
	transform: matrix3d(); /*es una funcion CSS que define una matriz de transformacion 3D del tipo 4x4 homogenea. Sus parámetros son:
	matrix3d(a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3, a4, b4, c4, d4)*/
}

/*-----CLIP PATH------*/
/*Es una propiedad que nos permite crear elementos con formas que no sean rectangulos. Utiliza las funciones circle, ellipse o polygon.*/
.caja1 {
	clip-path: circle(40%); /*define un circulo usando el radio y su posicion. */
	clip-path: ellipse(130px 140px at 10% 20%); /*define una elipse usando dos radios y la posicion del elemento*/
	clip-path: polygon(50% 0, 100% 50%, 50% 100%, 0 50%); /*define un poligono*/
	/*Para sacar el mayor provecho a esta propiedad lo mejor es utilizar generadores: como por ejemplo: https://bennettfeely.com/clippy/*/
}


/*--------BACKGROUND--------*/
/*Existen algunas propiedades del background que es interesante desglosar.*/
body {
	background-color: #ff0000;
	background-image: url(https://blog.ida.cl/wp-content/uploads/sites/5/2020/04/tamano-redes-blog-655x470.png);

	background-size: cover; /*lo mismo que en object fit*/
	/*cuando una imagen tiene mucho contenido, el background tiende a ser muy largo. Por lo tanto existe una propiedad que repite la imagen del background si un solo ejemplar de esta no logra llenar todo el contenedor. Esto sucede más cuando background-size tiene el valor contain*/
	background-repeat: no-repeat; /*repeat o no-repeat*/

	/*Son dos propiedades para indicar el area desde donde se coloca la imagen en nuestro contenedor, tomando en cuenta el padding, el borde, el contenido, etc. background-clip recorta la imagen para colocarla y background-origin posiciona la imagen para colocarla (luego la recorta)*/
	background-clip: border-box;
	background-clip: padding-box;
	background-clip: content-box;

	background-origin: border-box;
	background-origin: padding-box;
	background-origin: content-box;

	background-position: right bottom; /*Especifica como se posiciona la imagen en el contenedor, recibe dos parametros, la alineacion en x y luego la alineacion en y*/

	background-attachment: scroll; /*Posiciona la imagen y la mueve respecto a su contenedor. Cuando se realiza el scroll la imagen se mueve*/
	background-attachment: fixed; /*Posiciona la imagen respecto al viewport. La imagen no se mueve al hacer scroll*/
}

/*-------VARIABLES--------*/
/*Por obvias razones es interesante declarar variables en CSS, para hacer esto recurrimos a la siguiente sintaxis. Cabe resaltar que existen variables globales, las cuales se pueden utilizar en todo el documento. Para declararlas se crea un selector root y se conforma una variable dando dos guiones medios seguido del nombre de la variable y su valor. Luego para invocar a la variable en otro selector se llama a la funcion var() y se le da como parámetro el nombre de la variable*/
:root {
	--colorDeFondo: #f40;
	--colorDeMenu: #f60;
}
.container {
	background-color: var(--colorDeFondo);
}
/*Las variables locales sirven solo en el tipo del selector en el que trabajan. Es decir si creamos una variable en un selector tipo p, esta variable estara disponible solo para los selectores tipo p*/
p  {
	--color-letra: #d55;
}


/*--------FILTER--------*/
/*Es una propiedad para dar filtros a las imagenes*/
div {
	filter: none; /*propiedad por defecto, no hace nada*/
	filter: blur(130px); /*da un desenfoque gaussiano el valor va en px, em o rem*/
	filter: brightness(5); /*da brillo a la imagen, con 0 nada de brillo y 1 el brillo actual, en este caso el brillo es 5 veces más alto*/
	filter: contrast(1.5); /*aumenta el contraste de la imagen, 0 es nada de contraste y 1 el contraste actual, aqui seria 1,5 veces de contraste*/

	filter: drop-shadow(0px 0px 10px #acc); /*genera un sombreado en imagenes sin fondo, el box-shadow lo hace en el contenedor*/
	filter: grayscale(50%); /*escala de grises, 0 es nada y 1 es el máximo. 1 es el valor por defecto. Tmb funciona por porcentajes*/
	filter: hue-rotate(75deg); /*rota la gama de colores, se da un valor en deg, rad, grad*/
	filter: invert(70%); /*invierte la gama de colores, 0% es el original y 100% es completamente inverso*/
	filter: opacity(0.6); /*es la opacidad, en 0 es transparente y en 1 es totalmente opaco*/
	filter: saturate(200%); /*saturacion, 0 es nada saturado, 100% es normal, y un valor más alto es una gran saturacion*/
	filter: sepia(0.9); /*sepia, 0 es nada y 1 es máximo*/
}


/*--------SCROLL BEHAVIOR-----------*/
/*Cuando damos un enlace por ID a una seccion de la página que esta más abajo, podemos hacer que la transicion sea más suave, esto se logra haciendo que el scroll entre el boton por ID y la seccion de la página a la que queremos ir se haga de manera más lenta*/
.body {
	scroll-behavior: smooth; /*La propiedad se la da al container que contenga el scroll*/
}

/*---------USER SELECTED------------*/
/*Con esta propiedad controlamos si el usuario puede seleccionar algún elemento o texto*/
.container p {
	user-select: none;
}

/*-------FUNCION CALC()--------*/
/*La funcion calc() nos permite realizar calculos sencillos (suma, resta, producto y cociente) y nos ahorra el trabajo de las unidades, para así tener todo más optimizado*/
section {
	height: calc(100% - 2*10px);
}

/*-----FORMAS AVANZADAS DE SELECCIONAR--------*/
/*Hay formas de establecer relaciones entre selectores para más especificidad. */
.contenedor > p {
	color: #0000ff; /*Con el simbolo mayor que, seleccionamos los elementos que son hijos directos de .contenedor*/
}
div + p {
	color: #ff0000; /*Aqui seleccionamos el elemento hermano que este inmediatamente despues del div. Esto se llama hermano adjunto*/
}
div ~ p {
	color: #ff0000; /*Con este simbolo seleccionamos todos los elementos hermanos p que esten despues del div*/
}

/*Finnnn, espero que esto te ayude mucho José del futuro!!*/
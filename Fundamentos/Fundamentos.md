![Logo.png](Logo.png)

# FUNDAMENTOS DE PROGRAMACI√ìN
El presente archivo trata de dar una lecci√≥n concisa, pero a la vez profunda, acerca de todo lo necesario para introducirse en la programaci√≥n. Aqu√≠ se encontrar√°n los temas seccionados y explicados de forma fiel y pr√°ctica, intentando abarcar la mayoria de ellos como son operadores, tipos de dato y programaci√≥n orientada a objetos.

Esperamos sea de mucha utilidad. üòÉüòÉ

---

## 1. DEFINICIONES
### **1.1. ¬øQue es la programaci√≥n?**
La "Programaci√≥n", en su sentido m√°s amplio, es la acci√≥n de programar, que implica ***ordenar, estructurar o componer una serie de acciones cronol√≥gicas para cumplir un objetivo***. De esta definici√≥n tan amplia podemos decir que la programaci√≥n se puede aplicar en √°mbitos tan diversos como los eventos sociales, los medios de comunicaci√≥n, la resoluci√≥n de cualquier tipo de problemas y, por supuestro, el mundo inform√°tico y las computadoras.

Ya entrando en una definici√≥n m√°s formal, y sobre todo m√°s √∫til a lo que venimos a estudiar. Podemos decir que en inform√°tica, ***la programaci√≥n es el uso de lenguajes inform√°ticos para darle instrucciones a un ordenador***. Est√°s instrucciones estar√°n enfocadas en lograr que la computadora realice distintas tareas por nosotros, como c√°lculos matem√°ticos, decisiones l√≥gicas, almacenamiento de datos, etc.

Luego el fin de la programaci√≥n ser√° generar al final un resultado √∫til para el hombre. Otra definici√≥n acerca de la programaci√≥n deja esto bien en claro, ***el fin √∫ltimo de la programaci√≥n resulta en crear soluciones inform√°ticas a problemas del mundo real***.

Para poner lo anterior en resumen, dejo esta peque√±a definici√≥n elaborada por mi:
>‚ÄúLa Programaci√≥n es la acci√≥n de dar √≥rdenes a una m√°quina en pos de crear soluciones con software a problemas reales del hombre.‚Äù


### **1.2. ¬øQu√© es un Algoritmo y un Programa?**
Como _algoritmo_ denominamos un conjunto ordenado y finito de operaciones e instrucciones simples a trav√©s de las cuales podemos hallar la soluci√≥n a un problema. As√≠, dado un estado inicial y una entrada, y siguiendo los sucesivos pasos indicados, se llega al estado final y se obtiene una soluci√≥n.

Un conjunto de algoritmos constituye un _programa_. En general la palabra programa tambien se suele usar para llamar al producto inform√°tico terminado y listo para usar.

### **1.3 Lenguajes de Programaci√≥n**
Las instrucciones que se envian a la m√°quina no se pueden dar de cualquier manera, existe una estandarizaci√≥n de ellas para que puedan ser entendidas de forma general. Con este fin se crearon los __lenguajes de programaci√≥n__, que proporcionan una _sintaxis_ especifica de los comandos.

Hay muchos lenguajes de programaci√≥n dependiendo de quien los haya creado y el fin especifico para el que se quieran usar, en general, los m√°s conocidos tienen una sintaxis similar entre ellos.

Al hablar de **sintaxis** hablamos de una serie de palabras clave que indican ordenes para la computadora. Estas palabras clave no se podr√°n usar para otra cosa que no sea el fin que se dispuso, caso contrario confundiriamos al ordenador, es por eso que tambien se llaman _palabras reservadas_.

Viendo lo anterior con un ejemplo en el lenguaje "Java", para almacenar un dato debemos declarar que es lo que se va a guardar con la palabra reservada `int`, asignar un nombre al dato y luego utilizar el s√≠mbolo `=` para asignar el valor. Finalmente debemos cerrar la instrucci√≥n con el s√≠mbolo `;`. 

```JAVA
int datoNumerico = 1;
```

De este modo se establece una estructura r√≠gida que define la instrucci√≥n en una suerte de codifiaci√≥n que la m√°quina entiende, por ello tambien a los comandos de un lenguaje se los denomina _c√≥digo_.

### **1.4. Compilaci√≥n e Interpretaci√≥n**
Tambien se debe tener en cuenta es que las m√°quinas sobre la base "[0,1]", es decir solo entienden valores binarios. Esto implica que todo el c√≥digo que podamos escribir se deber√° traducir a lenguaje m√°quina (binario) para ser usado. 

A la acci√≥n de traducir un lenguaje a c√≥digo m√°quila la llamamos _compilar_, y los programas que realizan la tarea se llaman _compiladores_.

√öltimamente gracias a los avances en rendimiento de los ordenadores se ha optado por otra alternativa a los lenguajes compilados, los lenguajes interpretados. Aqu√≠ el c√≥digo se compila en tiempo real y se ejecuta al mismo tiempo eliminando as√≠ la necesidad de un archivo intermedio.

Esto es una ventaja para el desarrollo de software y la simplicidad de uso, pero trae aparejado el problema de un mayor consumo de recursos. Adem√°s, la velocidad de ejecuci√≥n del programa nunca ser√° tan r√°pida como la de los lenguajes compilados a binario.

![Img1.png](Img1.png)


### **1.5 Paradigmas de Programaci√≥n**
Un paradigma de programaci√≥n es una manera o estilo de programaci√≥n de software. Los lenguajes de programaci√≥n adoptan uno o varios paradigmas en funci√≥n del tipo de √≥rdenes que permiten implementar. Los hay muchos, pero aqu√≠ veremos solo dos:

- **Paradigma imperativo:** Los programas consisten en una sucesi√≥n de instrucciones o conjunto de sentencias, como si el programador diera √≥rdenes concretas. El desarrollador describe en el c√≥digo paso por paso todo lo que har√° su programa. El programa tiene un flujo de lectura en orden descendente y hay algunas sentencias que nos permiten controlar el flujo de este.

    Es el paradigma de programaci√≥n m√°s antiguo y en √©l se fundan todos los dem√°s.

- **Programaci√≥n orientada a objetos:** En este modelo se construyen funciones y m√©todos que realicen tareas espec√≠ficas y luego se los va agrupando en colecciones afines las cuales se llamar√°n "objetos".
Permite separar los diferentes componentes de un programa (modularizar el c√≥digo), simplificando as√≠ su creaci√≥n, depuraci√≥n y posteriores mejoras. La programaci√≥n orientada a objetos disminuye los errores y promociona la reutilizaci√≥n del c√≥digo. Es una manera especial de programar, que se acerca de alguna manera a c√≥mo expresar√≠amos las cosas en la vida real.

    Podemos definir un objeto como una estructura abstracta que, de manera m√°s fiable, describe un posible objeto del mundo real y su relaci√≥n con el resto del mundo que lo rodea a trav√©s de interfaces (conjuntos de acciones que puede realizar). Ejemplos de lenguajes de programaci√≥n orientados a objetos ser√≠an Java, Python o C#.

---

## 2. VARIABLES Y TIPOS DE DATOS
Las *variables* son espacios reservados en la memoria de  nuestro ordenador que se utilizan para poder guardar datos de manera temporal y usarlos en el programa. Los datos pueden ser numeros, cadenas de texto, o incluso cosas m√°s complejas, siempre se debe especificar que es lo que se va a almacenar.


Especificar que tipo de informaci√≥n se va a almacenar se denomina _definir el tipo de dato_, y se debe realizar con una palabra clave reservada. En general los lenguajes comparten varias de las palabras clave que identifican cada tipo de dato. A continuaci√≥n dejamos una lista de algunos de ellos:

|Tipo de Dato|Descripci√≥n|
|:---:|:---|
|Integer| Almacena n√∫meros enteros.|
|Float| Almacena n√∫meros reales con coma flotante.|
|String| Almacena cadenas de texto y car√°cteres unicode|
|Boolean| Almacena valores booleanos, es decir `True` o `False`|
|Char| Almacena un caracter de texto|

Luego puede resultar el caso de que se necesite cambiar el tipo de dato de una variable, es decir _hacer un Casting_. 

_Castear_ en programaci√≥n es una operaci√≥n para cambiar el tipo de dato del valor resultante de una expresi√≥n, por ejemplo, si queremos sumar dos valores num√©ricos, nos deber√≠amos asegurar que el lenguaje reconoce estos dos valores c√≥mo n√∫meros y no como un String.

---

## 3. TIPADO FUERTE, DEBIL Y DIN√ÅMICO
- **Tipado fuerte:** Un lenguaje de programaci√≥n es fuertemente tipado si no se permiten violaciones de los tipos de datos, es decir, al definir una variable se debe definir el tipo de dato y inicializada la misma no se puede usar como si fuera de otro tipo distinto a menos que se haga una conversi√≥n.

    Sus ventajas son:
    - La ejecuci√≥n es m√°s veloz, ya que la inferencia de los tipos es anterior y el lenguaje no necesita verificarlos a la hora de ejecutarlos.
    
    Sus desventajas son:
    - A la hora de programar es mucho m√°s estricto y necesitas escribir m√°s c√≥digo, lo que alarga el tiempo de trabajo.
    - El compilador debe ejecutar una disciplina de tipos concreta. Es decir, se siguen unas normas concretas de asignaci√≥n de variables, argumentos de funciones o valores de retorno.

    El tipado fuerte se usa en lenguajes de programaci√≥n como C, C#, Java y Ruby.

- **Tipado d√©bil:** En los lenguajes con tipado debil no se necesita declarar el tipo de dato a almacenar, el tipo de dato es inferido por la computadora cuando se inicializa la variable con un valor.

    Sus ventajas son:
    - Es muy r√°pido de desarrollar.
    - Su flexibilidad ayuda a que los programas funcionen sin necesidad de utilizar tanto c√≥digo.

    Presenta desventajas como:
    - Favorece la aparici√≥n de errores como el que se pierde al comparar n√∫meros mezclando algunos tipados como los strings, que no son detectables anteriormente.
    - Es necesario _castear_ de manera peri√≥dica el programa para conseguir el resultado esperado.

    Un lenguaje de tipado debil es PHP.

- **Tipado Din√°mico:** Los lenguajes de tipado din√°mico son aquellos (como JavaScript) donde el int√©rprete asigna a las variables un tipo de dato durante el tiempo de ejecuci√≥n basado en su valor en ese momento.

---

## 4. ESTRUCTURAS DE DATOS
En ciencias de la computaci√≥n, una estructura de datos‚Äã es una forma particular de organizar datos en una computadora para que puedan ser utilizados de manera eficiente. Diferentes tipos de estructuras de datos son adecuados para diferentes tipos de aplicaciones, y algunos son altamente especializados para tareas espec√≠ficas.
ARRAY VECTOR Y MATRIZ
LISTAS TIPO PILA Y COLA
ARBOLES
JSON y BSON

https://es.wikipedia.org/wiki/Estructura_de_datos
https://en.wikipedia.org/wiki/List_of_data_structures#Linear_data_structures
https://medium.com/techwomenc/estructuras-de-datos-a29062de5483
https://openwebinars.net/blog/que-son-las-estructuras-de-datos-y-por-que-son-tan-utiles/

---

## 5. OPERADORES
Un operador es un signo o s√≠mbolo que especifica el tipo de c√°lculo que se realiza en una expresi√≥n. Hay operadores matem√°ticos, de comparaci√≥n, l√≥gicos y de referencia.

### **2.1. Operadores de Asignacion:** 
Un operador de asignacion asigna un valor al operando de la izquierda basado en el valor del operando de la derecha.
```javascript
let numero = 10;
numero = 5;     //Asignacion. Asignar√° el valor de 5.
numero += 5;    //Asignacion de Adicion. Sumar√° 5 unidades a la variable n√∫mero. 
numero -= 5;    //Asignacion de Sustraccion. Restar√° 5 unidades a la variable n√∫mero.
numero *= 5;    //Asignacion de multiplicacion. Multiplicar√° por 5 el valor de la variable n√∫mero.
numero /= 5;    //Asignacion de division. Dividir√° por 5 el valor de la variable n√∫mero.
numero %= 5;    //Asignacion de resto. Har√° un cociente donde el n√∫merador ser√° la variable n√∫mero y el denominador 5. Devolver√° el resto.
numero **= 5;   //Asignacion de exponenciacion. Realizar√° una potenciaci√≥n de √≠ndice 5 a la variable n√∫mero.
```

### **2.2. Operadores Aritmeticos:**
Son operadores que toman valores numericos (ya sean literales o variables) como sus operandos y retornan un valor numerico unico. Realizan las operaciones aritm√©ticas b√°sicas.

```javascript
let num1 = 10, num2 = 5;

num1--;      //sustraccion en una unidad
num2++;      //incremento en una unidad
num1 + num2; //suma de dos valores
num1 - num2; //resta de dos valores
num1 * num2; //producto de dos valores
num1 / num2; //division de dos valores
num1**num2;  //potencia de base num1
```

### **2.3. Operadores L√≥gicos o de Comparaci√≥n:**
Los operadores de comparaci√≥n se usan para comparar valores y devolver un resultado que sea True, False o Null. Es decir se usan para validaciones l√≥gicas y retornan un valor Booleano. 

```javascript
let num1 = 23;
let num2 = "13";

//Con el operador == validamos si el valor de las dos variables es igual, independientemente del tipo de dato.
num1 == num2;

//Con el operador != validamos si el valor de las dos variables es desigual, independientemente del tipo de dato.
num1 != num2;

//Con los operadores === y !== validamos si son estrictamente iguales o desiguales respectivamente, es decir validamos la igualdad o desigualdad del valor y la igualdad o desigualdad del tipo de dato.
num1 === num2
num1 !== num2

//Con > validamos si num1 es mayor a num2. 
num1 > num2

//Con > validamos si num1 es menor a num2.
num1 < num2

//Con > validamos si num1 es mayor o igual a num2.
num1 >= num2

//Con > validamos si num1 es menor o igual a num2.
num1 <= num2

//Operador de Coalescencia nula. Devuelve el valor de la derecha si lo de la izquierda es null.
const foo = null ?? 'default string';
console.log(foo);
// salida esperada: "default string"
```
Notese que todos los operadores l√≥gicos trabajan devolviendo valores booleanos, es decir valores de true o false. Luego, a los operadores `==` y `!=` se los llama operadores de "semejanza" y a los operadores `===` y `!==`, se los llama operadores de "equivalencia".

### **2.4. Otros operadores L√≥gicos:**
Estos operadores se utilizan en conjunto con los anteriores para realizar m√∫ltiples validaciones en una sola operaci√≥n.

__Operador AND:__ Si todas las condiciones booleanas son verdaderas, devuelve _true_, caso contrario devuelve _false_.
```javascript
let num1 = 2, num2 = 4;

//Ambas condiciones son verdaderas, por lo que esta sentencia retornar√° true.
num1 < num2 && num1 != num2;
```
__Operador OR:__ Si al menos una de todas las afirmaciones es verdadera, devolvera _true_, sino devolvera _false_.
```javascript
num1 = 3; num2 = 6;

//La segunda condici√≥n no se cumple, pero se cumple al menos una, la primera, por lo que la sentencia retornar√° true.
num1 < num2 && num1 == num2;
```

__Operador NOT:__ Devuelve el valor opuesto, es decir que si la sentencia se cumple, retornar√° _false_ y caso contrario, retornar√° _true_.
```javascript
//La condicion se cumple, se retorna false.
!(num1 < num2);
```

Existen otros operadores basados en puertas l√≥gicas, estos en general no est√°n incluidos por defecto en los lenguajes, pero se pueden modelar a partir de los operadores anteriores. Un ejemplo de modelado es con el operador `xor`. El cual en una funcion javascript se ver√≠a de la siguiente manera:
```javascript
function xor(a,b) {
    return(a === !b);
}
```
Donde retornar√° verdadero solo si √°mbas proposiciones booleanas, (`a` y `b`) son distintas. Su tabla de verdad ser√≠a la siguiente:

![Img1.png](Img1.png)


Tambien es importante aclarar la nocion de _"Cortocircuitar"_ en el operador `AND`, la cual es una palabra de la jerga condicional y que expresa que una expresion condicional, por m√°s larga que sea, dejar√° de evaluarse si se dan determinados casos. Por ejemplo, basta con que en la siguiente expresi√≥n, la primer sentencia (`a == b`) retorne _false_, para que toda la expresion se deje de analizar.

`a == b && c !== (a + b) && d === ((c + b) - a)`

Entender esto resulta √∫til en la optimizaci√≥n de operaciones booleanas complejas o repetitivas, ya que siempre ser√° m√°s √≥ptimo colocar la condici√≥n m√°s sencilla de resolver al inicio.

---

## 6. PROGRAMACION IMPERATIVA:
### **6.1. Flujo normal de un Programa:**
Todo programa tiene un orden de ejecuci√≥n de las sentencias, esto se denomina _flujo de ejecucion_ del programa. Por defecto el flujo de cualquier programa es del tipo secuencial si no se especifica otra cosa.

En un flujo secuencial las sentencias se ejecutan en el orden de lectura, una despu√©s de otra. Para cambiar esta situaci√≥n se utilizan las estructuras de control de flujo, que permiten modificarlo a convenciencia.

Las estructuras de control de flujo t√≠picas son las siguientes:
- **Sentencias condicionales:** Ejecutan un bloque de c√≥digo si se cumple una condici√≥n booleana dada.
    - Sentencia "if-else".
    - Sentencia "switch-case".

- **Bucles:** Ejecutan un bloque de c√≥digo de manera reiterada mientras se cumpla una condici√≥n booleana dada. Son √∫tiles para tareas repetitivas.
    - Bucle "For".
    - Bucle "While".
    - Bucle "Do-While".

- **Sentencia "try-catch-finally":** Esta sentencia nos permite manejar excepciones al c√≥digo y especificar que hacer si ocurren situaciones no contempladas en el c√≥digo.

### **6.2. Sentencia Condicional "if-else":**
### **6.3. Sentencia Condicional "switch-case":**
### **6.4. Bucle "for":**
### **6.5. Bucle "while":**
### **6.6. Bucle "do-while":**
### **6.7. Sentencia "try-catch-finally:"**

---

## 7. FUNCIONES Y PROCEDIMIENTOS:
las funciones: 
Son trozos de codigo que se pueden reutilizar al invocarlos. Su sintaxis es sencilla, se declaran con la palabra "function" y se les coloca un nombre, luego se le pasan par√°metros a traves de un par de par√©ntesis y por √∫ltimo se escribe el c√≥digo a reutilizar encerrado entre llaves. 
Tambien es posible hacer que la funcion retorne un valor utilizando la sentenia "return();", cabe aclarar que esta sentencia adem√°s finaliza la ejecucion de la funcion.
### **4.1. ¬øQue son los procedimientos?:**
### **4.2. Las funciones, un caso especial de los procedimientos:**

---

## 8. PROGRAMACI√ìN ORIENTADA A OBJETOS:

### **8.1. Conceptos de POO:**
La programaci√≥n orientada a objetos es un paradigma de programacion en donde se busca crear elementos funcionales de manera sencilla e intuitiva. Para ello creamos en primera instancia plantillas generales y gen√©ricas (clases), que nos permitan luego crear objetos diversos pero con cualidades o atributos similares y luego utilizar funciones o m√©todos para que nuestro objeto adquiera funcionalidad. Su utilidad es que podemos resumir mucho c√≥digo de forma intuitiva.

Otra forma de ver a la programaci√≥n orientada a objetos es que con ella creamos distintas funciones (m√©todos) y las agupamos seg√∫n afinidad en objetos. De este modo podemos reutilizar mucho c√≥digo simplemente llamando al objeto y a la funcion que necesitemos en lugar de declararla nuevamente.

Notes√© que para que este paradigma funcione de manera correcta debemos hacer funciones lo m√°s gen√©ricas (y por ende lo m√°s reutilizables) posibles. En otras palabras, debemos trabajar por crear una l√≥gica en las funciones que este completamente desacoplada de los distintos frameworks que utilicemos para desarrollar nuestro producto inform√°tico.


Veamos algunos conceptos importantes:
1. __Clase:__ Es una porci√≥n de c√≥digo que contendra todas las caracter√≠sticas o atributos de nuestro objeto (las variables), y todas las cosas que puede hacer nuestro objeto (los m√©todos). Se utiliza como una base para objetos gen√©ricos. Por ejemplo podemos crear una clase `Usuario`, la cual tendra los m√©todos `.notificar()`, `.consultarSaldo()`, `.modificarPerfil()` y `.verCompras()`.

2. __Objeto:__ Es el resultado de instanciar nuestra clase, es decir el elemento que surge cuando llamamos a una clase y la usamos. Este elemento nuevo es un objeto propiamente dicho. Los objetos no dejan de ser colecciones de elementos.

3. __Atributos:__ Son todas las caracteristicas que tendra nuestro objeto, es decir las variables. Estas se declaran en la "plantilla" clase, dentro de una funcion especial llamada contructor.

4. __Metodos:__ Los m√©todos son simplemente funciones cl√°sicas, solo que tienen una sintaxis especial que unicamente se puede usar dentro de la clase.

5. __Constructor:__ Es una funcion especial y obligatoria que debe tener cualquier clase, aqui se inicializan las variables o atributos que tendr√° nuestro objeto.

6. __M√©todos estaticos:__ Son m√©todos que se pueden utilizar sin necesidad de definir ning√∫n objeto. Se los puede llamar y usarlos sin antes crear al objeto.

7. __Polimorfismo:__ Es la capacidad de un objeto de comportarse de manera distinta dependiendo de los valores de las variables o atributos. Un ejemplo de ello es que podemos crear un m√©todo `notificar()` en una clase `User`, y hacer que este m√©todo envie un mail, un whatsapp o un mensaje de texto dependiendo de los atributos que tenga el objeto creado. Por ejemplo un usuario cuyos atributos nos digan que no tiene email o whatsapp pero si un numero de telefono, sera notificado de las novedades solo por mensajes de texto.

8. __Herencia:__ Es la capacidad de heredar metodos y atributos de otra clase, y usarlas en una nueva.

9. __Abstraccion:__ Es una forma de programar clases en donde se busca definir un objeto con las m√≠nimas lineas de codigo, m√©todos y atributos posibles, y a su vez con la mayor generalidad posible.

10. __Encapsulamiento:__ Es declarar nuestras variables de maneras protegidas o privadas, para que los dem√°s objetos no puedan acceder a ellos. Esto es por seguridad y para evitar conflictos.

11. __Setter y getter:__ Los setters son m√©todos para modificar los atributos de un objeto, con la sentencia "set" definimos o modificamos un atributo, y con la sentencia "get" retornamos el valor de un atributo.

Realizemos con lo anterior un ejemplo de clase gen√©rica. Esta clase sera la "plantilla" para crear animales.
```javascript
//Declaramos una nueva clase de nombre "animal".
class animal {

    //Elemento constructor, donde declaramos las variables.
    constructor(especie, edad, color) {

        //Inicializamos variables a usar en la clase con this.nombreDeLaVariable = valor; esta sintaxis solo se usa dentro de las clases.
        this.especie = especie;
        this.edad = edad;
        this.color = color;

        this.info = null;
    }

    //M√©todo o funci√≥n para saludar, el objeto nos va a decir sus caracter√≠sticas.
    saludar() {
        info = `Soy un ${this.especie}, tengo ${this.edad} a√±os y soy de color ${this.color}.`;
        document.write(this.info + "<br>");
    }

    //M√©todo con polimorfismo. El m√©todo se comporta de manera distinta dependiendo de la especie.
    ladrar() {
        if(this.especie == perro) {
            document.write("<b>¬°WaW!<b><br>");
        } else {
            document.write("El animal no puede ladrar ya que es un" + this.especie + "<br>");
        }
    }
    //M√©todo est√°tico de ejemplo.
    static buenosDias(){
        alert("Hola, buenos dias");
    }

    //M√©todos setter y getter:
    set setModificarEspecie(newName){
        this.especie = newName;
    }
    get getEspecie() {
        return this.especie;
    }
}
```
Es importante resaltar que:
1. Las variables declaradas dentro de los par√©ntesis y que utilizamos para recibir los par√°metros, son distintas a las variables que se inicializan en el constructor. Por esto debemos igualarlas.
2. Las "arrow-function" no funcionan dentro de las clases.
3. No podemos nombrar a ning√∫n objeto con el mismo nombre de la clase utilizada.

Para utilizar la clase "animal" empleamos la siguiente sintaxis.
```javascript
//Instanciamos la clase animal y creamos tres objetos con sus atributos.
const perro = new animal("perro", "5 a√±os", "marr√≥n");
const gato = new animal("gato", "2 a√±os", "negro");
const perico = new animal("perico", "1 a√±o", "verde");

//Imprimimos el valor del atributo color, del objeto "perro".
document.write(perro.color);

//Imprimimos la informaci√≥n de los atributos del  objeto "perro".
document.write(perro.info + "<br>");

//Ejecutamos el m√©todo saludar para cada objeto animal.
perro.saludar();
gato.saludar();
perico.saludar();

//Llamamos al m√©todo que posee polimorfismo.
perro.ladrar();   //Si el objeto tiene la especie perro se imprimira ¬°WaW!, caso contrario se dir√° que el objeto no puede ladrar.
perico.ladrar();  //En el caso del perico, se dir√° que este animal no puede ladrar.

//Uso de un m√©todo estatico, no hace falta llamar a ning√∫n objeto, la funcion simplemente se ejecuta llamando al m√©todo e indicandole la clase que lo contiene.
animal.buenosDias();

//Uso del setter. Para usarlo lo hacemos como si fuera una propiedad m√°s.
perico.setModificarEspecie = "canario";
//uso del getter.
document.write(perico.getEspecie);
```
Utilizemos ahora conceptos de Herencia en nuestras clases, para ello utilizamos la palabra reservada extends.
```javascript
//Creamos una clase "dog" que extienda a la clase "animal".
class dog extends animal {
    constructor(especie,edad,color,raza) {
        //Con la siguiente sentencia indicamos que los atributos especie, edad y color. Se heredan de la clase animal.
        super(especie,edad,color);

        //El nuevo atributo raza lo declaramos de la manera tradicional.
        this.raza = raza;
    }
}
```
Utilicemos nuestra clase "dog", recien creada:
```javascript
//Creamos un objeto perrito de la clase dog, vemos que podemos usar los m√©todos de la clase animal sin ningun problema.
const perrito = new dog("perro","2 a√±os","gris","doberman");
perrito.saludar();
perrito.ladrar();
```
## Operador .this()
El operador this es una forma de llamar al objeto contexto de JavaScript en el cual se est√° ejecutando el c√≥digo actual. Es decir hace referencia al elemento en el que se esta ejecutando.
Si this se usa en el contexto de ejecucion global (fuera de cualquier funcion u objeto), este operador se refiere al objeto global.

Ejemplos de uso de ``.this` en contextos locales o de funciones.
```javascript
//Un ejemplo
function f1(){
  return this;
}

f1() === window; // objeto global


//otro ejemplo.
var o = {
  prop: 37,
  f: function() {
    return this.prop;
  }
};

console.log(o.f()); // logs 37
```

Ejemplos de uso de `.this` en contextos globales.
```javascript
console.log(this.document === document); // true

// En los navegadores web, el objeto window tambi√©n es un objeto global:
console.log(this === window); // true

this.a = 37;
console.log(window.a); // 37
```
El valor de this permanecera en el estado en el que se encuentre actualmente si se trabaja en modo estricto.
### **7.. Lenguajes Basados en Prototipos:**
## Prototipos:
La programaci√≥n basada en prototipos es un estilo de programacion, en donde los objetos se crean por herencia de otros objetos prototipos, m√°s que por instanciacion de los mismos.
Todos los elementos en javascript son objetos, y los mismos tienen una coleccion de propiedades heredadas de otros objetos m√°s primitivos, llamados objetos prototipo.

Un ejemplo de esto son las variables, las cuales al declararse heredan dos prototipos, el prototipo correspondiente al tipo de dato y el prototipo object. Este √∫ltimo es el prototipo m√°s general de todos.

Con el siguiente c√≥digo podemos imprimir el consola los dos prototipos asociados a la variable "valor". El prototipo number y el prototipo object.
```javascript
let valor = 5;
console.log(valor.__proto__);
```

Luego existen otros elementos en javascript como las funciones, las cuales nos dejan a nuestro criterio su prototipo. Es decir nosotros creamos sus prototipos (el prototipo object se mantiene de todos modos).

```javascript
const f = function(){};

console.log(f.__proto__); //Este comando no nos devolvera ning√∫n prototipo. Porque no estamos utilizando ning√∫n prototipo heredado (excepto el object, el cual es el prototipo por defecto). Simplemente lo creamos nosotros.

console.log(f.prototype); //Este comando nos devolver√° el prototipo de la funcion, el cual nosotros habremos creado. 

//Luego para acceder al prototipo object deberiamos escribir.
console.log(f.prototype.__proto__);
```

## 8. NOCIONES DE "CLEAN CODE"




